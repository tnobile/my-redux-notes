export const Box = ({ color, msg }) => (
  <div
    style={{
      padding: 20,
      backgroundColor: color,
      width: "50%",
      display: "inline-block",
      textAlign: "center",
      fontSize: "150px",
    }}
  >
    {msg}
  </div>
);

# ¡Hóla, MDX!

This is **markdown** with <span style={{color: "red"}}>JSX</span>: MDX!

<div>
  <Box color="tomato" msg="左" />
  <Box color="orange" msg="右" />
</div>

<hr />

# React-Redux

In summary, to connect Redux to React, you must do the following:

1. Install and import react-redux
2. Wrap your root App component inside of react-redux's Provider component
3. Import connect into the component you'd like to pull Redux state into
4. Create a mapStateToProps function that determines what state you'd like to pull from your store
5. Export your component using connect, taking mapStateToProps as an argument
6. Pass through your state as an argument to your render function
7. Render your state

Redux is simply a library that ensures we follow a certain pattern to update our global state.

# References

- <https://chriscourses.com/blog/redux>
- <https://github.com/hstevanoski/react-redux-notes-app/tree/hooks/src>
- <https://github.com/devAbhimanyu/Redux-toolkit/tree/createSlice>
- <https://www.softkraft.co/how-to-setup-redux-with-redux-toolkit/>
- <https://redux-toolkit.js.org/api/createSlice>

# Todo

- todo
- async hook
- backend
- fix mdx

# hooks

- useSelctor
- useDispatcher
- useStore
- useEffect
- useState

# redux

1. Actions & Action Creators ( action + payload )
2. Reducers (switch on actions)
3. Store (createStore)

# createSlice

the files structure: we can put all of our Redux-related logic for the slice into a single file.
consists of :

- name: a parameter that will be the prefix for all of your action types
- initialState: the initial values for our reducer
- reducers: it's an object where the keys will become action type strings, and the functions are reducers that will be run when that action type is dispatched.

# ducks

Redux.org recommend that most applications should structure files using a "feature folder" approach (all files for a feature in the same folder) or the "ducks" pattern (all Redux logic for a feature in a single file), rather than splitting logic across separate folders by "type" of code (reducers, actions, etc).

# action creators

console.log(createPost({ id: 123, title: 'Hello World' }))
// {type : "posts/createPost", payload : {id : 123, title : "Hello World"}}


# dispatch (Higher Order Function/Component)

If you don't specify the second argument to connect(), your component will receive dispatch by default. For example:
```
 connect()(MyComponent)
 // which is equivalent with
 connect(null, null)(MyComponent)

 // or
 connect(mapStateToProps /** no second argument */)(MyComponent)
```
if you provide mapDispatchToProps in the 2nd paramter, Therefore, instead of calling props.dispatch(() => increment()), you may call props.increment() directly. 
