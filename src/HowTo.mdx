export const Box = ({ color, msg }) => (
  <div
    style={{
      padding: 20,
      backgroundColor: color,
      width: "50%",
      display: "inline-block",
      textAlign: "center",
      fontSize: "150px",
    }}
  >
    {msg}
  </div>
);

# ¡Hóla, MDX!

This is **markdown** with <span style={{color: "red"}}>JSX</span>: MDX!

<div>
  <Box color="tomato" msg="左" />
  <Box color="orange" msg="右" />
</div>

<hr />

# React-Redux

In summary, to connect Redux to React, you must do the following:

1. Install and import react-redux
2. Wrap your root App component inside of react-redux's Provider component
3. Import connect into the component you'd like to pull Redux state into
4. Create a mapStateToProps function that determines what state you'd like to pull from your store
5. Export your component using connect, taking mapStateToProps as an argument
6. Pass through your state as an argument to your render function
7. Render your state

Redux is simply a library that ensures we follow a certain pattern to update our global state.

# References

- <https://chriscourses.com/blog/redux>
- <https://github.com/hstevanoski/react-redux-notes-app/tree/hooks/src>
- <https://github.com/devAbhimanyu/Redux-toolkit/tree/createSlice>
- <https://www.softkraft.co/how-to-setup-redux-with-redux-toolkit/>
- <https://redux-toolkit.js.org/api/createSlice>

# Todo

- todo
- async hook
- backend
- fix mdx

# hooks

- useSelctor
- useDispatcher
- useStore
- useEffect
- useState

# redux

1. Actions & Action Creators ( action + payload )
2. Reducers (switch on actions)
3. Store (createStore)

# createSlice

the files structure: we can put all of our Redux-related logic for the slice into a single file.
consists of :

- name: a parameter that will be the prefix for all of your action types
- initialState: the initial values for our reducer
- reducers: it's an object where the keys will become action type strings, and the functions are reducers that will be run when that action type is dispatched.

# ducks

Redux.org recommend that most applications should structure files using a "feature folder" approach (all files for a feature in the same folder) or the "ducks" pattern (all Redux logic for a feature in a single file), rather than splitting logic across separate folders by "type" of code (reducers, actions, etc).

# action creators

console.log(createPost({ id: 123, title: 'Hello World' }))
// {type : "posts/createPost", payload : {id : 123, title : "Hello World"}}


# dispatch (Higher Order Function/Component)

If you don't specify the second argument to connect(), your component will receive dispatch by default. For example:
```
 connect()(MyComponent)
 // which is equivalent with
 connect(null, null)(MyComponent)

 // or
 connect(mapStateToProps /** no second argument */)(MyComponent)
```
if you provide mapDispatchToProps in the 2nd paramter, Therefore, instead of calling props.dispatch(() => increment()), you may call props.increment() directly. 


# object spread operator

https://redux.js.org/recipes/using-object-spread-operator


# redux-thunk

“Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions. 
This inverts the control: you will get dispatch as an argument, so you can write an action creator that dispatches many times.
It is a 1middleware that looks at every action that passes through the system, and if it’s a function, it calls that function. That’s all it does.
https://daveceddia.com/what-is-a-thunk/
https://daveceddia.com/where-fetch-data-redux/

```js
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
		// This gets called for every action you dispatch.
		// If it's a function, call it.
    if (typeof action === 'function') {
      return action(dispatch, getState, extraArgument);
    }

		// Otherwise, just continue processing this action as usual
    return next(action);
  };
}

const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
```
The word "thunk" is a programming term that means "a piece of code that does some delayed work". For more details, see these posts:


# fetch async await
https://dmitripavlutin.com/javascript-fetch-async-await/
https://javascript.plainenglish.io/how-to-make-your-js-fetch-not-look-so-ugly-f45c89f8bc3a
